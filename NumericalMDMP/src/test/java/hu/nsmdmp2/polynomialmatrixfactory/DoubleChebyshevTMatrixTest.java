package hu.nsmdmp2.polynomialmatrixfactory;

import static hu.nsmdmp2.polynomialmatrixfactory.ChebyshevTMatrix.generateChebyshevTMatrix;
import static hu.nsmdmp2.tools.SetNormalization.normalize;
import static hu.nsmdmp2.utils.Converters.primitiveToDoubleValue;
import static org.junit.Assert.assertArrayEquals;
import hu.nsmdmp2.numerics.Value;

import org.junit.Test;

public class DoubleChebyshevTMatrixTest {
	@Test
	public void test() {

		int maxOrder = 1;
		double[][] set = { { 0, 1, 2, 3 }, { 0, 1, 2, 3 } };

		Value[][] normalizedM = normalize(primitiveToDoubleValue(set));
		Value[][] M = generateChebyshevTMatrix(normalizedM, maxOrder);

		Value[][] expected = primitiveToDoubleValue(new double[][] { //
				{ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 }, //
				{ -1.0, -1.0 / 3.0, 1.0 / 3.0, 1.0, -1.0, -1.0 / 3.0, 1.0 / 3.0, 1.0, -1.0, -1.0 / 3.0, 1.0 / 3.0, 1.0, -1.0, -1.0 / 3.0, 1.0 / 3.0, 1.0 },
				{ -1.0, -1.0, -1.0, -1.0, -1.0 / 3.0, -1.0 / 3.0, -1.0 / 3.0, -1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 1.0, 1.0, 1.0, 1.0 } });

		int i = 0;
		for (Value[] array : expected) {
			assertArrayEquals("row = " + i + ": ", array, M[i]);
			i++;
		}
	}

	@Test
	public void test2() {

		int maxOrder = 2;
		double[][] set = { { 0, 1, 2, 3 }, { 0, 1, 2, 3 } };

		Value[][] normalizedM = normalize(primitiveToDoubleValue(set));
		Value[][] M = generateChebyshevTMatrix(normalizedM, maxOrder);

		Value[][] expected = primitiveToDoubleValue(new double[][] { //
				{ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
				{ -1.0, -1.0 / 3.0, 1.0 / 3.0, 1.0, -1.0, -1.0 / 3.0, 1.0 / 3.0, 1.0, -1.0, -1.0 / 3.0, 1.0 / 3.0, 1.0, -1.0, -1.0 / 3.0, 1.0 / 3.0, 1.0 },
				{ 1.0, -7.0 / 9.0, -7.0 / 9.0, 1.0, 1.0, -7.0 / 9.0, -7.0 / 9.0, 1.0, 1.0, -7.0 / 9.0, -7.0 / 9.0, 1.0, 1.0, -7.0 / 9.0, -7.0 / 9.0, 1.0 },
				{ -1.0, -1.0, -1.0, -1.0, -1.0 / 3.0, -1.0 / 3.0, -1.0 / 3.0, -1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0, 1.0, 1.0, 1.0, 1.0 },
				{ 1.0, 1.0 / 3.0, -1.0 / 3.0, -1.0, 1.0 / 3.0, 1.0 / 9.0, -1.0 / 9.0, -1.0 / 3.0, -1.0 / 3.0, -1.0 / 9.0, 1.0 / 9.0, 1.0 / 3.0, -1.0,
						-1.0 / 3.0, 1.0 / 3.0, 1.0 },
				{ 1.0, 1.0, 1.0, 1.0, -7.0 / 9.0, -7.0 / 9.0, -7.0 / 9.0, -7.0 / 9.0, -7.0 / 9.0, -7.0 / 9.0, -7.0 / 9.0, -7.0 / 9.0, 1.0, 1.0, 1.0, 1.0 } });

		int i = 0;
		for (Value[] array : expected) {
			assertArrayEquals("row = " + i + ": ", array, M[i]);
			i++;
		}
	}

	@Test
	public void test3() {

		int maxOrder = 1;
		double[][] set = { { 0, 1, 2, 3, 4 }, { 0, 1, 2, 3, 4 }, { 0, 1, 2, 3, 4 } };

		Value[][] normalizedM = normalize(primitiveToDoubleValue(set));
		Value[][] M = generateChebyshevTMatrix(normalizedM, maxOrder);

		Value[][] expected = primitiveToDoubleValue(new double[][] { //
				{ 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
						1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
						1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
						1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
						1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
				{ -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0,
						1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0,
						-1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0,
						0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0,
						1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0,
						-1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0,
						1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0, -1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0,
						-1.0, -1.0 / 2.0, 0.0, 1.0 / 2.0, 1.0 },
				{ -1.0, -1.0, -1.0, -1.0, -1.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 / 2.0, 1.0 / 2.0,
						1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0,
						-1.0 / 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0,
						-1.0, -1.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0,
						1.0 / 2.0, 1.0 / 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0,
						-1.0 / 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, -1.0,
						-1.0, -1.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0,
						1.0 / 2.0, 1.0 / 2.0, 1.0, 1.0, 1.0, 1.0, 1.0 },
				{ -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0,
						-1.0, -1.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0,
						-1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0,
						-1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, -1.0 / 2.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0,
						0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0,
						1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0,
						1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0 / 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
						1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0 } });

		int i = 0;
		for (Value[] array : expected) {
			assertArrayEquals("row = " + i + ": ", array, M[i]);
			i++;
		}
	}
}
